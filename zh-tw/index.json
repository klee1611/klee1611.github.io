[{"categories":["Concurrency Programming"],"content":"在 Python 3.4 之後出現了 Asyncio 可以在特定情境下提升效能， 結合之前已經有的 Multiprocessing 和 Multithreading， 我整理了一下這三項技術適合的原理、差異和使用情境做了幾篇紀錄。 這一篇先簡單介紹三者的基本概念和適用情境。 ","date":"2025-10-25","objectID":"/zh-tw/posts/python-concurrency-parallelism-multiprocessing-multithreading-asyncio.html:0:0","tags":["Python","Concurrency","Parallelism","Multiprocessing","Multithreading","Asyncio","Coroutine","GIL","Performance"],"title":"Multiprocessing, Multithreading and Asyncio in Python Part 1 - Basic Concept","uri":"/zh-tw/posts/python-concurrency-parallelism-multiprocessing-multithreading-asyncio.html"},{"categories":["Concurrency Programming"],"content":"Multiprocessing 一支程式可以同時執行多個獨立的行程 (Process)。 每個行程都有自己獨立的記憶體空間， 也因此可以完全避開 Python GIL (Global Interpreter Lock) 的限制。 這意味著它們可以真正地在多核心 CPU 上獨立的平行執行， 互不干擾。 適用情境： CPU 密集型任務 (CPU-bound)， 例如大量的數學運算、資料處理、影像辨識等。 可以有效利用多核心 CPU 的運算能力。 import multiprocessing import time def cpu_bound_task(n): count = 0 for i in range(n): count += i print(f\"Finished task with {n}\") if __name__ == '__main__': start_time = time.time() processes = [] for i in range(4): p = multiprocessing.Process(target=cpu_bound_task, args=(10**7,)) processes.append(p) p.start() for p in processes: p.join() end_time = time.time() print(f\"Multiprocessing took {end_time - start_time:.2f} seconds.\") 優點： 能夠利用 multi-core CPU 實現真正的平行運算。 不受 GIL 限制。 行程間記憶體獨立，穩定性高，不太會產生 Race Condition。 缺點： 獨立 Process 建立所需的資源較多。 行程間通訊 (IPC) 較為複雜，需要透過 Queue、Pipe 等機制。 ","date":"2025-10-25","objectID":"/zh-tw/posts/python-concurrency-parallelism-multiprocessing-multithreading-asyncio.html:1:0","tags":["Python","Concurrency","Parallelism","Multiprocessing","Multithreading","Asyncio","Coroutine","GIL","Performance"],"title":"Multiprocessing, Multithreading and Asyncio in Python Part 1 - Basic Concept","uri":"/zh-tw/posts/python-concurrency-parallelism-multiprocessing-multithreading-asyncio.html"},{"categories":["Concurrency Programming"],"content":"Multithreading 在單一 Process 裡建立多個執行緒 (Thread)。 這些 thread 共享同一個 Process 使用的記憶體空間， 因此可以輕鬆地進行資料共享與交換。 值得一提的是， 在一定版本之前， Python 和其他程式語言如 C/C++ 等不同的是， Python 的 multithreading 會受到 Python GIL (Global Interpreter Lock) 的限制， 即使是跑在多核心的 CPU 上， Python 的 multithreading 實際上也做不到平行運算。 隨著 Python 的使用者越來越多， 產生了 PEP-703 這樣的需求， 直到 Python 3.13 之後開始實驗性的包含了可以選擇性關閉 GIL 的功能 (free-threading mode)， Python 3.14 開始出現了無 GIL 的 Free-threaded 的版本。 GIL (Global Interpreter Lock): GIL 是 CPython (官方的 Python 實現) 中的一個機制， 為了保護 Python object 不會被損壞， 這個機制確保同一個時間點只有一個執行緒能執行 Python 的 bytecode。 這意味著在 CPU 密集型任務中， 即使在多核心 CPU 上， Python 的多執行緒也無法實現真正的平行運算。 不過當 Thread 遇到 I/O 操作 (如讀寫檔案、網路請求) 時會釋放 GIL， 讓其他 Thread 有機會執行。 因此 Multithreading 比較適合用來處理 I/O 密集型任務。 適用情境： I/O 密集型任務 (I/O-bound)， 例如網路爬蟲、檔案下載、API 請求等。 import threading import requests import time def io_bound_task(url): try: response = requests.get(url) print(f\"Downloaded {url} with status {response.status_code}\") except Exception as e: print(f\"Error downloading {url}: {e}\") if __name__ == '__main__': urls = [\"https://www.google.com\"] * 5 start_time = time.time() threads = [] for url in urls: t = threading.Thread(target=io_bound_task, args=(url,)) threads.append(t) t.start() for t in threads: t.join() end_time = time.time() print(f\"Multithreading took {end_time - start_time:.2f} seconds.\") 優點： 建立 thread 的開銷比 process 小。 共享記憶體，資料交換方便。 缺點： 受 GIL 限制，無法利用多核心 CPU 處理 CPU 密集型任務。 需要處理執行緒同步問題，如使用 Lock 來避免 Race condition。 ","date":"2025-10-25","objectID":"/zh-tw/posts/python-concurrency-parallelism-multiprocessing-multithreading-asyncio.html:2:0","tags":["Python","Concurrency","Parallelism","Multiprocessing","Multithreading","Asyncio","Coroutine","GIL","Performance"],"title":"Multiprocessing, Multithreading and Asyncio in Python Part 1 - Basic Concept","uri":"/zh-tw/posts/python-concurrency-parallelism-multiprocessing-multithreading-asyncio.html"},{"categories":["Concurrency Programming"],"content":"Asyncio I/O (Asyncio) 與 Coroutine 非同步是 Python 3.4 之後引入的標準函式庫， 概念上是利用 Event Loop 和 Coroutine 來實現 single thread 下的並行。 Coroutine 可以看作是一種輕量級的 thread， 可以被控制執行到某個點時暫停等待需要被執行的任務完成， 與此同時將控制權交還給 event loop 去執行其他 coroutine。 當暫停的條件完成後 (例如等待的 I/O 操作完成)， event loop 會再回來繼續執行該 coroutine。 除了可以在暫停時間執行其他 coroutine 之外， 也可以節省作業系統層級的執行緒切換， 可以提升不少效能。 適用情境： 高度並行的 I/O 密集型任務， 特別是需要同時處理大量網路連線的場景 (如 Web 伺服器、聊天應用)。 import asyncio import aiohttp import time async def async_io_bound_task(session, url): try: async with session.get(url) as response: print(f\"Downloaded {url} with status {response.status}\") except Exception as e: print(f\"Error downloading {url}: {e}\") async def main(): urls = [\"https://www.google.com\"] * 5 start_time = time.time() async with aiohttp.ClientSession() as session: tasks = [async_io_bound_task(session, url) for url in urls] await asyncio.gather(*tasks) end_time = time.time() print(f\"Asyncio took {end_time - start_time:.2f} seconds.\") if __name__ == '__main__': asyncio.run(main()) 優點： thread 切換的開銷極低，能夠以極高的效率處理大量 I/O 操作。 在 single thread 下運作，沒有 race condition 的問題。 缺點： 不適用於 CPU 密集型任務。 需要使用 async/await 語法，且需要有對應的非同步函式庫支援 (如 aiohttp)。 ","date":"2025-10-25","objectID":"/zh-tw/posts/python-concurrency-parallelism-multiprocessing-multithreading-asyncio.html:3:0","tags":["Python","Concurrency","Parallelism","Multiprocessing","Multithreading","Asyncio","Coroutine","GIL","Performance"],"title":"Multiprocessing, Multithreading and Asyncio in Python Part 1 - Basic Concept","uri":"/zh-tw/posts/python-concurrency-parallelism-multiprocessing-multithreading-asyncio.html"},{"categories":["Concurrency Programming"],"content":"比較總結 特性 多程序 (Multiprocessing) 多執行緒 (Multithreading) 非同步 (Asyncio) 基本單位 行程 (Process) 執行緒 (Thread) 協程 (Coroutine) 記憶體空間 獨立 共享 共享 (單執行緒) GIL 影響 無，可繞過 受限制 無 (單執行緒) 平行/並行 平行 (Parallelism) 並行 (Concurrency) 並行 (Concurrency) 適用情境 CPU 密集型 I/O 密集型 高度並行的 I/O 密集型 優點 可利用多核心 共享記憶體 極高 I/O 效率、低開銷 缺點 資源開銷大、IPC 複雜 受 GIL 限制、有競爭條件 不適用 CPU 密集型任務 如果是 CPU-bound 的任務需求，需要大量 CPU 運算，那麼 multiprocessing 是最適合的，因為它能充分利用多核心 CPU 的威力。 如果是 IO-bound 的任務需求，且邏輯相對簡單，multithreading 是一個不錯的選擇，因為它比 multiprocessing 更輕量。 如果是 IO-bound 且需要處理大量的並行連線 (例如開發 Web 伺服器或 API)，那麼 asyncio 是效率最高的。 ","date":"2025-10-25","objectID":"/zh-tw/posts/python-concurrency-parallelism-multiprocessing-multithreading-asyncio.html:4:0","tags":["Python","Concurrency","Parallelism","Multiprocessing","Multithreading","Asyncio","Coroutine","GIL","Performance"],"title":"Multiprocessing, Multithreading and Asyncio in Python Part 1 - Basic Concept","uri":"/zh-tw/posts/python-concurrency-parallelism-multiprocessing-multithreading-asyncio.html"},{"categories":["Tools"],"content":"原先我使用的筆記軟體是 Notion， 功能豐富且介面美觀， 但幾年前 Notion 出現了隱私權爭議， 被指控偷看某公司放在 Notion 的內容， 甚至進一步提出合作； 就改用了一陣子 Joplin， 但最後還是轉到了擁有大量外掛及社群支援， 而且可以高度客製化的 Obsidian。 Joplin 原先就支援 WebDAV 同步， 轉到 Obsidian 後我找到了 Remotely save 這個也支援 WebDAV 的 plugin， 方便我將筆記儲存在自己的 NAS 上， 同時可以在不同裝置之間保持同步。 ","date":"2024-12-25","objectID":"/zh-tw/posts/sync-obsidian-joplin-data-across-multiple-device-synology-webdav.html:0:0","tags":["WebDAV","Synology","Obsidian","Joplin"],"title":"Sync Obsidian / Joplin Data Across Multiple Device with Synology WebDAV","uri":"/zh-tw/posts/sync-obsidian-joplin-data-across-multiple-device-synology-webdav.html"},{"categories":["Tools"],"content":"WebDAV 和 HTTPS Certificate 設定 - 穿透 Router 連線內網 NAS 上的 WebDAV server ","date":"2024-12-25","objectID":"/zh-tw/posts/sync-obsidian-joplin-data-across-multiple-device-synology-webdav.html:1:0","tags":["WebDAV","Synology","Obsidian","Joplin"],"title":"Sync Obsidian / Joplin Data Across Multiple Device with Synology WebDAV","uri":"/zh-tw/posts/sync-obsidian-joplin-data-across-multiple-device-synology-webdav.html"},{"categories":["Tools"],"content":"設備 Router: Synology RT2600AC NAS: Synology 918+ ","date":"2024-12-25","objectID":"/zh-tw/posts/sync-obsidian-joplin-data-across-multiple-device-synology-webdav.html:1:1","tags":["WebDAV","Synology","Obsidian","Joplin"],"title":"Sync Obsidian / Joplin Data Across Multiple Device with Synology WebDAV","uri":"/zh-tw/posts/sync-obsidian-joplin-data-across-multiple-device-synology-webdav.html"},{"categories":["Tools"],"content":"環境建立 Synology NAS 上安裝 WebDAV Server 套件後， 基於安全性考量在 WebDAV 的設定關閉 HTTP 連線， 只開啟 HTTPS 存取權限 （雖然不是很確定， 不過手機版的 Joplin 似乎因為安全性限制也只能用 HTTPS）， 然後在 router 上的網路設定將對應的 Port forwarding 做設定如圖， 由於之前也經設定過 router 的 DDNS， 所以原先就可以透過網址連線到 router； 於是我就直接進行了 WebDAV 的連線測試， 我在 Joplin 的連線設定選了 WebDAV， 把網址跟 port 號還有要儲存筆記的資料夾放在 WebDAV 的網址列 （如： https://.....:5xxx/homes/xxx/xxx/xxx）， 點了測試連線後就發現 certificate 出現問題， google 了一陣子之後發現是因為連線時網址的 domain name 是對應到 router， router 再把連線導到 NAS， 但在 NAS 上卻沒有找到該 domain name 的 certificate， 導致了 Joplin 連線的時候 certificate 跟網址對不上， （可以用 https://www.geocerts.com/ssl-checker 檢查）； 於是我從 router 把 certificate export 出來以後放到 NAS 上， 然後在 NAS 上找到設定 certificate 的地方， 把 WebDAV 的 certificate 換成從 router import 進來的， 設定如下圖， 然後去 https://www.geocerts.com/ssl-checker 又做了一次測試， 這次確認了 HTTPS 連線到的 port 的 certificate 是正確的， 再回到 Joplin 的連線設定測試一遍確認連線成功後就可以順利同步了。 ","date":"2024-12-25","objectID":"/zh-tw/posts/sync-obsidian-joplin-data-across-multiple-device-synology-webdav.html:1:2","tags":["WebDAV","Synology","Obsidian","Joplin"],"title":"Sync Obsidian / Joplin Data Across Multiple Device with Synology WebDAV","uri":"/zh-tw/posts/sync-obsidian-joplin-data-across-multiple-device-synology-webdav.html"},{"categories":["Tools"],"content":"補充資訊 - Notion 隱私權爭議 2020 年一篇在Notion.Taiwan 台灣官方社群的貼文 中有人提到， Notion 會偷看用戶資料甚至提出合作： 最後 Notion 官方聲明 移除了引發爭議的 Business Development and Strategic Partnerships 條款 ","date":"2024-12-25","objectID":"/zh-tw/posts/sync-obsidian-joplin-data-across-multiple-device-synology-webdav.html:2:0","tags":["WebDAV","Synology","Obsidian","Joplin"],"title":"Sync Obsidian / Joplin Data Across Multiple Device with Synology WebDAV","uri":"/zh-tw/posts/sync-obsidian-joplin-data-across-multiple-device-synology-webdav.html"},{"categories":["Develop environment"],"content":"今天遇到一個問題， 安裝過 nvm 後安裝 global package 的路徑就被改變了， 導致想要移除之前安裝過的 global package 時沒辦法直接用 npm uninstall -g 移除。 怎麼發現這件事的呢？ 很久以前我在 global 裝過一個 package 可以直接在 terminal 呼叫 command 執行， 但因為年代久遠， 要升級那個 package 的時候發現他不在 npm list -g 的範圍， 只好先用 which 看一下他在的位置， 接著發現是一個 link 然後就用 ls -al 看那個 link 連到哪裡， 發現是在 /usr/lib/node_modules 底下， 很明顯是用 npm -g 安裝的， 於是再仔細的看了一下 npm list -g 的結果， 發現其他的 global package 都列在 /Users/\u003cUSER_NAME\u003e/.nvm/versions/node/v16.5.0/lib 底下， 在一陣 google 之後找到了一個方式 nvm use system \u0026\u0026 npm ls -g --depth=0 來列出原本安裝過的 global package 有哪些， 悲劇的是他跳出了 System version of node not found. 看來我已經移除了系統裡的 node … 於是我又找到了一個 command nvm deactivate 暫時 disable nvm ， 然後用 brew 再安裝一次 node ， 接著再 npm list -g 一次， 終於讓我看到那個在安裝 nvm 之前安裝過的 package 了！！！ 可喜可賀！！ 終於可以順利的移除 / 升級之前安裝的 global package 了。 搞定之後要重新把 nvm 叫回來只要用 source ~/.zshrc 之類的重啟 shell 就可以了。 ","date":"2021-11-06","objectID":"/zh-tw/posts/managing-pre-exist-global-npm-packages-after-installing-nvm.html:0:0","tags":["NVM","NPM","Node.js","Global Packages","Troubleshooting"],"title":"Managing Pre-existing Global NPM Packages After Installing NVM","uri":"/zh-tw/posts/managing-pre-exist-global-npm-packages-after-installing-nvm.html"},{"categories":["Develop environment"],"content":"pyenv 的功能和使用的原因 pyenv 是用來在系統裡安裝各種不同版本的 python， 並能夠方便的切換 python 版本的工具。 當同時有不同 python 版本的專案需要開發或維護時， 就會需要使用 pyenv 來協助切換 python 的版本。 python 的新版本通常都會有一些語法上的更新或是新增一些功能， 例如 python 的 async / await 就是 python 3.5 以上才出現的功能， 用 python 3.5 以下的版本來開發的專案就無法使用； 又或者例如同時有 python 2 和 python 3 的專案， 而且因為 python 2 和 python 3 語法不相容， 勢必要在系統裡安裝 python 2 和 python 3； 諸如次類的情況就可以使用 pyenv 方便的切換 python 的版本。 ","date":"2021-11-01","objectID":"/zh-tw/posts/pyenv-notes.html:0:1","tags":["Programming","Python","Pyenv"],"title":"Pyenv Notes","uri":"/zh-tw/posts/pyenv-notes.html"},{"categories":["Develop environment"],"content":"安裝和初始化 安裝 brew install pyenv 安裝完畢後執行初始化 pyenv init 之後按照指示將顯示的 code 貼到 ~/.zshrc 或 ~/.bash_profile ","date":"2021-11-01","objectID":"/zh-tw/posts/pyenv-notes.html:0:2","tags":["Programming","Python","Pyenv"],"title":"Pyenv Notes","uri":"/zh-tw/posts/pyenv-notes.html"},{"categories":["Develop environment"],"content":"常用指令 列出可以安裝的 python 版本 pyenv install --list 會出現 Available versions: 2.1.3 2.2.3 2.3.7 2.4.0 ... 3.9.6 3.9.7 3.10.0 3.10-dev 3.11.0a1 ... 安裝指定版本的 python pyenv install 3.10.0 觀察已經安裝過哪些版本的 python pyenv versions 會出現 * system (set by ......./.pyenv/version) 3.10.0 代表目前有系統預設的版本跟剛剛安裝過的 3.10.0， 但目前使用 python 的是系統預設版本 切換系統使用版本 pyenv global 3.10.0 到系統任何地方下 pyenv versions 都會看到目前使用的 python 版本是 3.10.0 只切換當前目錄下的 python 版本 pyenv local 3.7.12 在當前目錄下 pyenv versions 會看到正在使用的是 3.7.12 的版本； 但是到其他目錄下， 假如之前有用 pyenv global 設定過版本 (假設是 3.10.0)， 則 pyenv versions 會看到的是之前用 pyenv global 設定的版本 (3.10.0)； 假如沒有跑過 pyenv global 設定版本則 pyenv versions 會出現系統預設的版本。 解除安裝指定的 python 版本 pyenv uninstall 3.7.12 ","date":"2021-11-01","objectID":"/zh-tw/posts/pyenv-notes.html:0:3","tags":["Programming","Python","Pyenv"],"title":"Pyenv Notes","uri":"/zh-tw/posts/pyenv-notes.html"},{"categories":["Develop environment"],"content":"Reference pyenv Github ","date":"2021-11-01","objectID":"/zh-tw/posts/pyenv-notes.html:1:0","tags":["Programming","Python","Pyenv"],"title":"Pyenv Notes","uri":"/zh-tw/posts/pyenv-notes.html"},{"categories":["Concurrency Programming"],"content":"在出現 asyncio 前， 當一隻 Python 程式有很多需要並行執行的 task， 想要提升程式效能， 只能選用 multiprocessing 或 threading； Python 3.4 之後又多出了 asyncio 的選擇。 asyncio 可以用來撰寫 coroutines， 並使用 event loop 並行執行 coroutines， 減少程式不必要的等待時間以提升效能。 ","date":"2021-10-27","objectID":"/zh-tw/posts/python-coroutine-asyncio.html:0:0","tags":["Programming","Python","Concurrent Processing"],"title":"Python Coroutine Asyncio","uri":"/zh-tw/posts/python-coroutine-asyncio.html"},{"categories":["Concurrency Programming"],"content":"Coroutines ","date":"2021-10-27","objectID":"/zh-tw/posts/python-coroutine-asyncio.html:1:0","tags":["Programming","Python","Concurrent Processing"],"title":"Python Coroutine Asyncio","uri":"/zh-tw/posts/python-coroutine-asyncio.html"},{"categories":["Concurrency Programming"],"content":"Coroutine 定義 在 Python 官方文件 定義裡， Python coroutines 是 Coroutines are a more generalized form of subroutines. Subroutines are entered at one point and exited at another point. Coroutines can be entered, exited, and resumed at many different points. They can be implemented with the async def statement. See also PEP 492. 意指 Python 的 coroutine 和 subroutines 相當類似， 不同的地方在於 subroutine 是開始之後直接一次執行到底， 執行完後結束； 而 coroutine 則可以執行到某處暫停， 之後再繼續恢復執行。 ","date":"2021-10-27","objectID":"/zh-tw/posts/python-coroutine-asyncio.html:1:1","tags":["Programming","Python","Concurrent Processing"],"title":"Python Coroutine Asyncio","uri":"/zh-tw/posts/python-coroutine-asyncio.html"},{"categories":["Concurrency Programming"],"content":"用 async, await 和 asyncio.run 定義並執行 coroutine async 可以用來定義一個 coroutine， 只要在定義 function 的 def 前加上 async 就可以用 async def 定義一個 coroutine。 await 用來定義一個 coroutine 的暫停處， 執行到 await 時， coroutine 就可以暫停， 之後再恢復執行。 await 後面只能接 awaitable object， awaitable object 包含 coroutine 或 event loop 的 task 等。 import asyncio async def ten_sec_sleep(): await asyncio.sleep(10) print('10 sec sleep finish') if __name__ == '__main__': asyncio.run(ten_sec_sleep()) ","date":"2021-10-27","objectID":"/zh-tw/posts/python-coroutine-asyncio.html:1:2","tags":["Programming","Python","Concurrent Processing"],"title":"Python Coroutine Asyncio","uri":"/zh-tw/posts/python-coroutine-asyncio.html"},{"categories":["Concurrency Programming"],"content":"Event Loop ","date":"2021-10-27","objectID":"/zh-tw/posts/python-coroutine-asyncio.html:2:0","tags":["Programming","Python","Concurrent Processing"],"title":"Python Coroutine Asyncio","uri":"/zh-tw/posts/python-coroutine-asyncio.html"},{"categories":["Concurrency Programming"],"content":"What is event loop 在 Python 官方文件 裡， 介紹的 Event loop The event loop is the core of every asyncio application. Event loops run asynchronous tasks and callbacks, perform network IO operations, and run subprocesses. 簡單來說就是用來跑異步執行的 task 的。 Event loop 每次只會執行一個 task， 使用 event loop 跑 coroutines 時， 當 task 執行到 programmer 定義的暫停處， event loop 會將該 task 暫停並排程， 接著切換執行其他的工作（可能是其他的 task 或 callback 等）， 這也使得 event loop 和 coroutine 的組合特別適合用來處理 IO bound task； 將 coroutine I/O 運作的部分定為暫停處， 並使用 event loop 來跑這些 coroutines 時就能夠將等待 I/O 的時間切換做其他的工作。 ","date":"2021-10-27","objectID":"/zh-tw/posts/python-coroutine-asyncio.html:2:1","tags":["Programming","Python","Concurrent Processing"],"title":"Python Coroutine Asyncio","uri":"/zh-tw/posts/python-coroutine-asyncio.html"},{"categories":["Concurrency Programming"],"content":"以 Event loop 執行 coroutines 執行單一一個 coroutine： import asyncio async def ten_sec_sleep(count): await asyncio.sleep(10) print(f'10 sec sleep finish, count: {count}') if __name__ == '__main__': loop = asyncio.get_event_loop() task = loop.create_task(ten_sec_sleep(0)) loop.run_until_complete(task) 執行時間用 time command 看是 10.09 秒 10 sec sleep finish, count: 0 10.09 real 0.06 user 0.01 sys 多個 coroutine 並行執行： import asyncio async def ten_sec_sleep(count): await asyncio.sleep(10) print(f'10 sec sleep finish, count: {count}') if __name__ == '__main__': loop = asyncio.get_event_loop() tasks = [] for i in range(10): tasks.append(loop.create_task(ten_sec_sleep(i))) loop.run_until_complete(asyncio.wait(tasks)) 每當執行到 sleep(10) 的時候 event loop 就可以切換到其他 coroutine 去執行， 並行執行 coroutine 的時間用 time command 看是 10.09 秒 10 sec sleep finish, count: 0 10 sec sleep finish, count: 1 10 sec sleep finish, count: 2 10 sec sleep finish, count: 3 10 sec sleep finish, count: 4 10 sec sleep finish, count: 5 10 sec sleep finish, count: 6 10 sec sleep finish, count: 7 10 sec sleep finish, count: 8 10 sec sleep finish, count: 9 10.09 real 0.07 user 0.01 sys ","date":"2021-10-27","objectID":"/zh-tw/posts/python-coroutine-asyncio.html:2:2","tags":["Programming","Python","Concurrent Processing"],"title":"Python Coroutine Asyncio","uri":"/zh-tw/posts/python-coroutine-asyncio.html"},{"categories":["Concurrency Programming"],"content":"效能測量 一支連續發 10 個 requests 到 google 的程式， 在不使用 coroutine 的情況下： import requests def issue_req(count): resp = requests.get('http://www.google.com.tw') print(f'count: {count}, resp status: {resp.status_code}') if __name__ == '__main__': for i in range(10): issue_req(i) 用 time command 看需要的時間是 0.83 秒 count: 0, resp status: 200 count: 1, resp status: 200 count: 2, resp status: 200 count: 3, resp status: 200 count: 4, resp status: 200 count: 5, resp status: 200 count: 6, resp status: 200 count: 7, resp status: 200 count: 8, resp status: 200 count: 9, resp status: 200 0.83 real 0.16 user 0.05 sys 使用 coroutine 來並行發出 requests： import requests import asyncio async def issue_req(count): loop = asyncio.get_event_loop() resp = await loop.run_in_executor( None, requests.get, 'http://www.google.com.tw' ) print(f'count: {count}, resp status: {resp.status_code}') if __name__ == '__main__': loop = asyncio.get_event_loop() tasks = [] for i in range(10): tasks.append(loop.create_task(issue_req(i))) loop.run_until_complete(asyncio.wait(tasks)) 用 time command 看需要的時間是 0.31 秒 count: 0, resp status: 200 count: 2, resp status: 200 count: 3, resp status: 200 count: 7, resp status: 200 count: 5, resp status: 200 count: 1, resp status: 200 count: 9, resp status: 200 count: 6, resp status: 200 count: 8, resp status: 200 count: 4, resp status: 200 0.31 real 0.18 user 0.05 sys 以這 10 個 requests 來看， 從 0.83 秒到 0.31 秒， 效能提升了 (0.83 - 0.31)/0.83 * 100% = 62.65% ， 相當顯著； 對有相當多 I/O bound task 的程式來說， 使用 coroutine 是個不錯的選擇。 ","date":"2021-10-27","objectID":"/zh-tw/posts/python-coroutine-asyncio.html:3:0","tags":["Programming","Python","Concurrent Processing"],"title":"Python Coroutine Asyncio","uri":"/zh-tw/posts/python-coroutine-asyncio.html"},{"categories":["Develop environment"],"content":"Why Pipenv 當有很多 Python project 要維護， 不同的 project 有可能使用相同的 python libraries 的不同版本， 不使用 virtual environment 而將所有的 python modules 都裝在自己的機器上就會造成版本衝突。 過去使用 virtualenv + requirement.txt 的機制可以在不同的 project 使用同一個套件的不同版本， 也能夠讓新加入的開發者或 production 環境可以快速安裝 project 需要的套件， 但當套件需要更新時相當麻煩， 需要手動再去倒出一份新的 requirement.txt， 而且當 project 有不同環境的需求的時候(例如 development 環境和 production 環境)還要維護requirement-prod.txt 和 requirement-dev.txt 兩份套件設定， 如果不搭配 pyenv 也無法切換不同的 python 版本。 後來發現了 Python 官方推薦的 pipenv 解決了這些問題， 可以方便的只用 command 做到： 建立獨立的 python 版本和套件虛擬環境 安裝並記錄套件版本到自動生成的 Pipfile 和 Pipfile.lock，同時透過套件的 Hash 值檢查套件安全性 紀錄套件使用環境 (分開 development 和 production 環境) 讀取 .env 檔案設定虛擬環境的環境變數 自動切換系統中的 python 版本（或 pyenv 有安裝的 python 版本） ","date":"2021-09-26","objectID":"/zh-tw/posts/pipenv-notes.html:1:0","tags":["Programming","Python","Pipenv"],"title":"Pipenv Notes","uri":"/zh-tw/posts/pipenv-notes.html"},{"categories":["Develop environment"],"content":"操作 Pipenv ","date":"2021-09-26","objectID":"/zh-tw/posts/pipenv-notes.html:2:0","tags":["Programming","Python","Pipenv"],"title":"Pipenv Notes","uri":"/zh-tw/posts/pipenv-notes.html"},{"categories":["Develop environment"],"content":"Install Pipenv pip3 install pipenv ","date":"2021-09-26","objectID":"/zh-tw/posts/pipenv-notes.html:2:1","tags":["Programming","Python","Pipenv"],"title":"Pipenv Notes","uri":"/zh-tw/posts/pipenv-notes.html"},{"categories":["Develop environment"],"content":"Pipenv Commands 建立特定 python 版本的獨立虛擬環境: 到 project 所在的目錄下 pipenv --python 3.8 注意該版本的 python 系統要有，不然就要用 pyenv 裝一下 安裝套件 pipenv install flask 安裝 development 套件 加上 --dev 的套件在自動生成的 Pipfile 中會被放到 [dev-packages] 底下 pipenv install pytest --dev 移除套件 pipenv uninstall flask 在建立的虛擬環境中執行 script pipenv run python server.py 也可以執行其他指令如 pytest pipenv run pytest 進入虛擬環境 pipenv shell 要離開虛擬環境時在輸入 exit 即可 用取得的 Pipfile 和 Pipfile.lock 建立虛擬環境 pipenv install 如果要連 development 環境的套件一起安裝 pipenv install --dev 從 requirement.txt 建立 Pipfile 和 Pipfile.lock pipenv install 輸出 requirement.txt 實際上不需要做這件事， 但在某些特殊情況下（例如特殊平台的需求）還是可以這樣做 pipenv lock --requirements \u003e requirements.txt 升級虛擬環境中的套件 pipenv update 刪除目前的虛擬環境 pipenv --rm ","date":"2021-09-26","objectID":"/zh-tw/posts/pipenv-notes.html:2:2","tags":["Programming","Python","Pipenv"],"title":"Pipenv Notes","uri":"/zh-tw/posts/pipenv-notes.html"},{"categories":["Develop environment"],"content":"Upgrade Pipenv pip3 install --upgrade pipenv","date":"2021-09-26","objectID":"/zh-tw/posts/pipenv-notes.html:2:3","tags":["Programming","Python","Pipenv"],"title":"Pipenv Notes","uri":"/zh-tw/posts/pipenv-notes.html"},{"categories":["Web"],"content":"Stateless HTTP HTTP 是一種 stateless 的 protocol， 也就是說每一次的 request / response 都是獨立的， 和之前或之後的 request / response 無關。 相同的 request 就會回應相同的 response， 不會因為之前的 request / response 內容而有不同。 這樣一來 server 因為不需要儲存使用者資訊可以省去大量的資料庫、伺服器儲存空間， 也因為不需要讓 client 每次都必須連線到相同的 socket 而能夠加快 response time 和省去不少 network bandwidth， 但在網站需要做連續動作（例如需要確認使用者身份認證時）就會需要一些機制來協助， 這時候大部分的網站就會利用 session 或 cookie。 ","date":"2021-06-28","objectID":"/zh-tw/posts/stateless-http-stateful-session-and-cookies.html:1:0","tags":["Web","Session","Cookie"],"title":"Stateless HTTP, Stateful Session and Cookies","uri":"/zh-tw/posts/stateless-http-stateful-session-and-cookies.html"},{"categories":["Web"],"content":"Session Session 是一段具有狀態 (stateful) 的時間。 HTTP request / response 是 stateless 的， 但如果透過 stateless 的 request / response 夾帶 state 資訊的話， client 和 server 就可以透過 request / response 夾帶的 state 資訊製造出 stateful 的運作。 例如說當某個動作必須要使用者登入並且選定了選項 A 後才能夠操作， 就希望能有一段具有狀態的時期 (session) 是“使用者已登入且選定了 A 選項”的狀態， 做出這個狀態的方式有許多種， 例如在這個期間的 request 透過攜帶加密過後的使用者 ID 和選項 A 來告訴 server 現在使用者已經登入、使用者的身份和選定的選項等。 做出 session 的做法可以有很多種， 最常見的是 cookie， 但 cookie 只是方法之一， 並不是說 session 一定只能透過 cookie 來實作， 透過別的方式也能做出 session， 例如利用 query string 來記錄前幾次的互動等。 ","date":"2021-06-28","objectID":"/zh-tw/posts/stateless-http-stateful-session-and-cookies.html:2:0","tags":["Web","Session","Cookie"],"title":"Stateless HTTP, Stateful Session and Cookies","uri":"/zh-tw/posts/stateless-http-stateful-session-and-cookies.html"},{"categories":["Web"],"content":"Cookie Cookie 是實作出 session 的一種機制， server 可以用 Set-Cookie 這個 Header 請 browser 設定 cookie 並指定 cookie 的內容， 之後 browser 在發送 request 到相同的 domain 和 path 時會將 cookie 帶入一併發送， 這樣一來在需要記憶某些 state 時， server 只要讓 browser 去設定需要的 cookie， 之後當發送 request 時 server 看到 cookie 的內容就能知道現在的 state 了。 由於 cookie 的內容可以在使用者端被自行修改， 所以為了安全性考量， 在使用 cookie 的時候有比較常見的兩種做法(也能兩者一起使用)： ","date":"2021-06-28","objectID":"/zh-tw/posts/stateless-http-stateful-session-and-cookies.html:3:0","tags":["Web","Session","Cookie"],"title":"Stateless HTTP, Stateful Session and Cookies","uri":"/zh-tw/posts/stateless-http-stateful-session-and-cookies.html"},{"categories":["Web"],"content":"Cookie-based session 將 cookie 內容加密， 傳到 server 後由 server 解密才知道 cookie 存的內容。 接續上面的例子就是將使用者 ID 和選項 A 加密後放進 cookie。 使用上要注意： 因為 Cookie 的大小有限制，所以加密後 cookie 的大小要特別注意不能太大 加密的 key 必須妥善保存 ","date":"2021-06-28","objectID":"/zh-tw/posts/stateless-http-stateful-session-and-cookies.html:3:1","tags":["Web","Session","Cookie"],"title":"Stateless HTTP, Stateful Session and Cookies","uri":"/zh-tw/posts/stateless-http-stateful-session-and-cookies.html"},{"categories":["Web"],"content":"Session ID 使用一個 ID (Session Identifier, Session ID) 來記錄使用者身份， 其餘的資料 (Session Data) 都儲存在 server。 接續上面的例子就是將使用者選定的選項 A 放在 server， cookie 裡放置使用者的 ID。 使用上要注意： Session ID 要設計的不好猜，一旦被猜中使用者的身份就會被偷走 如果網站不夠安全，一旦 Session ID 在某個頁面被其他惡意網站或駭客盜走，使用者的身份就會被偷走 ","date":"2021-06-28","objectID":"/zh-tw/posts/stateless-http-stateful-session-and-cookies.html:3:2","tags":["Web","Session","Cookie"],"title":"Stateless HTTP, Stateful Session and Cookies","uri":"/zh-tw/posts/stateless-http-stateful-session-and-cookies.html"},{"categories":["Develop environment"],"content":" 把在 Linux 和 Mac 上 terminal 的設定也搬到 Windows 上， 方便操作。 ","date":"2021-04-11","objectID":"/zh-tw/posts/wsl-2-on-windows-part-2.html:0:0","tags":["WSL","Ubuntu","Windows terminal"],"title":"WSL 2 on Windows Part 2 - Terminal 介面設定","uri":"/zh-tw/posts/wsl-2-on-windows-part-2.html"},{"categories":["Develop environment"],"content":"Windows Terminal 功能 用 Windows terminal 可以 啟用多個分頁 (在多個 Linux CLI、Windows CLI、PowerShell等之間快速切換) 自訂按鍵 (開啟或關閉分頁、複製+貼上等快速鍵) 使用搜尋功能 自訂佈景主題 這些功能比原生 WSL 能支援的多的多， 也可以設定的和我在 Linux 或 Mac 的開發環境比較相似， 於是就決定選用 windows terminal 了。 ","date":"2021-04-11","objectID":"/zh-tw/posts/wsl-2-on-windows-part-2.html:1:0","tags":["WSL","Ubuntu","Windows terminal"],"title":"WSL 2 on Windows Part 2 - Terminal 介面設定","uri":"/zh-tw/posts/wsl-2-on-windows-part-2.html"},{"categories":["Develop environment"],"content":"Windows terminal 設定 到 Microsoft store 搜尋 Windows terminal 並安裝完成後， 就可以開始設定 Windows terminal。 ","date":"2021-04-11","objectID":"/zh-tw/posts/wsl-2-on-windows-part-2.html:2:0","tags":["WSL","Ubuntu","Windows terminal"],"title":"WSL 2 on Windows Part 2 - Terminal 介面設定","uri":"/zh-tw/posts/wsl-2-on-windows-part-2.html"},{"categories":["Develop environment"],"content":"將 WSL 設定為 Windows terminal 預設開啟環境 在 windows terminal 的 [V] 箭頭選單選擇\"設定(settings)\"， 會出現一個 JSON 檔可以修改， 從 profiles 的 list 找到想要做為預設的 Linux distribution， 例如: { \"guid\": \"{xxxxxxxxxxxxxxx}\", \"hidden\": false, \"name\": \"Ubuntu-18.04\", \"commandline\": \"wsl.exe\", \"source\": \"Windows.Terminal.Wsl\" } 把 guid 後面那串被大括號括起來的 ID 複製起來， 用那個 ID 取代原本預設開啟的 profile 的 ID: \"defaultProfile\": \"{yyyyyy}\" (把 yyyyyy 的地方換成 Linux distribution 的 GUID) ","date":"2021-04-11","objectID":"/zh-tw/posts/wsl-2-on-windows-part-2.html:2:1","tags":["WSL","Ubuntu","Windows terminal"],"title":"WSL 2 on Windows Part 2 - Terminal 介面設定","uri":"/zh-tw/posts/wsl-2-on-windows-part-2.html"},{"categories":["Develop environment"],"content":"設定 Windows terminal 預設開啟目錄 把 JSON 設定檔的 Linux distribution profile 中的 \"commandline\": \"wsl.exe\", 後面補上預設要開啟的目錄 (~ 即為使用者 linux 的 home direcotry) \"commandline\": \"wsl.exe ~\", ","date":"2021-04-11","objectID":"/zh-tw/posts/wsl-2-on-windows-part-2.html:2:2","tags":["WSL","Ubuntu","Windows terminal"],"title":"WSL 2 on Windows Part 2 - Terminal 介面設定","uri":"/zh-tw/posts/wsl-2-on-windows-part-2.html"},{"categories":["Develop environment"],"content":"設定 Windows terminal Scheme 在 JSON 設定檔的 Linux distribution profile 裡加上這行: \"colorScheme\": \"One Half Dark\", One Half Dark 是 Windows 提供的其中一種色彩配置， 還有其他種可以在 Microsoft Doc: Windows 終端機中的色彩配置 中找尋。 ","date":"2021-04-11","objectID":"/zh-tw/posts/wsl-2-on-windows-part-2.html:2:3","tags":["WSL","Ubuntu","Windows terminal"],"title":"WSL 2 on Windows Part 2 - Terminal 介面設定","uri":"/zh-tw/posts/wsl-2-on-windows-part-2.html"},{"categories":["Develop environment"],"content":"設定 Windows terminal 字型 在 JSON 設定檔的 Linux distribution profile 裡加上 \"fontFace\": \"xxxxx\", xxxxx 的地方是字型的名稱。 如果有需要使用 Powerline 的需求的話可以先安裝好 Powerline fonts， 再把想要的字型名稱填進去。 ","date":"2021-04-11","objectID":"/zh-tw/posts/wsl-2-on-windows-part-2.html:2:4","tags":["WSL","Ubuntu","Windows terminal"],"title":"WSL 2 on Windows Part 2 - Terminal 介面設定","uri":"/zh-tw/posts/wsl-2-on-windows-part-2.html"},{"categories":["Develop environment"],"content":"Reference Microsoft Doc: 安裝和設定 Windows 終端機 設定 Windows Terminal 作為 WSL 操作介面 Microsoft Doc: Windows 終端機中的色彩配置 ","date":"2021-04-11","objectID":"/zh-tw/posts/wsl-2-on-windows-part-2.html:3:0","tags":["WSL","Ubuntu","Windows terminal"],"title":"WSL 2 on Windows Part 2 - Terminal 介面設定","uri":"/zh-tw/posts/wsl-2-on-windows-part-2.html"},{"categories":["Develop environment"],"content":"工作的時候習慣用 Linux 或 mac 的 terminal， 找了個時間在家裡的 PC 上把 WSL 的環境也設定一下方便切換工作環境。 ","date":"2021-04-10","objectID":"/zh-tw/posts/wsl-2-on-windows-part-1.html:0:0","tags":["WSL","Ubuntu"],"title":"WSL 2 on Windows Part 1 - 安裝啟用","uri":"/zh-tw/posts/wsl-2-on-windows-part-1.html"},{"categories":["Develop environment"],"content":"WSL 2 和 WSL 1 的差異 WSL 2 是基於 Hyper-V 在 virtual machine 中跑完整的 Linux kernal， WSL 1 則是在 Windows 系統上對 Linux 功能的模擬， 因此 WSL 2 比 WSL 1 支援更多 Linux 原生的功能和 system call。 如果需要用到 Linux 底層的應用， WSL 2 支援的能力比 WSL 1 更好。 一般情況下 WSL 2 啟動 process 的效能也更好， 但需要讀取 host 系統的檔案時除外。 但因為 WSL 2 是在 VM 上跑 Linux kernal， 因此和做為 host 的 Windows 的整合相對較 WSL 1 差。 在 WSL 2 裡的 process 無法在 Windwos 的工作管理員控管， Windows 和 WSL 2 的網路連線方式也多了一層。 因為 WSL 2 用了 Hyper-V 的關係， 所以有聽過跟 VMWare 不相容的災情。 我沒有用 VMWare 所以不知道是不是真的有這個 issue， 但用 Docker 的時候沒有產生問題。 Microsoft Doc 有列舉出 WSL 1 和 WSL 2 詳細的比較。 ","date":"2021-04-10","objectID":"/zh-tw/posts/wsl-2-on-windows-part-1.html:1:0","tags":["WSL","Ubuntu"],"title":"WSL 2 on Windows Part 1 - 安裝啟用","uri":"/zh-tw/posts/wsl-2-on-windows-part-1.html"},{"categories":["Develop environment"],"content":"Requirement Windwos 版本要是 Windows 10，低於這些版本的話請善用 Windows 更新: 若為 X64 系統：版本 1903 或更高版本，含 組建 18362 或更高組建。 若為 ARM64 系統：版本 2004 或更高版本，含 組建 19041 或更高組建。 機器要開啟虛擬化功能， 通常在主機板的 BIOS 設定裡可以找到， 找找跟 CPU 設定相關的地方應該會有一些 Intel Virtualization 有關的設定， 把它開起來。 ","date":"2021-04-10","objectID":"/zh-tw/posts/wsl-2-on-windows-part-1.html:2:0","tags":["WSL","Ubuntu"],"title":"WSL 2 on Windows Part 1 - 安裝啟用","uri":"/zh-tw/posts/wsl-2-on-windows-part-1.html"},{"categories":["Develop environment"],"content":"安裝啟用 WSL 2 用 admin 權限開啟 PowerShell， 啟用Windows 子系統 Linux 版: 執行 dism.exe /online /enable-feature /featurename:Microsoft-Windows-Subsystem-Linux /all /norestart 啟用虛擬機器平台選用功能: 執行 dism.exe /online /enable-feature /featurename:VirtualMachinePlatform /all /norestart 重新啟動電腦 下載安裝 WSL 2 Linux 核心更新套件 將 WSL 2 設定為預設版本 wsl --set-default-version 2 去 Microsoft Store 找想安裝的 Linux distribution， 並安裝設定帳號密碼 可以在 PowerShell 中檢查安裝的 Linux distribution 的 WSL 版本: wsl -l -v 也可以更改 Linux distribution 的 WSL 版本: wsl --set-version \u003cdistribution name\u003e \u003cversionNumber\u003e ","date":"2021-04-10","objectID":"/zh-tw/posts/wsl-2-on-windows-part-1.html:3:0","tags":["WSL","Ubuntu"],"title":"WSL 2 on Windows Part 1 - 安裝啟用","uri":"/zh-tw/posts/wsl-2-on-windows-part-1.html"},{"categories":["Develop environment"],"content":"Reference Microsoft WSL 2 安裝指南 Microsoft DOC: 比較 WSL 1 和 WSL 2 ","date":"2021-04-10","objectID":"/zh-tw/posts/wsl-2-on-windows-part-1.html:4:0","tags":["WSL","Ubuntu"],"title":"WSL 2 on Windows Part 1 - 安裝啟用","uri":"/zh-tw/posts/wsl-2-on-windows-part-1.html"},{"categories":["Programming"],"content":"Shallow Copy 複製越少越好， Shallow copy 出來的新的 structure 擁有跟舊的 structure 相同的結構， 並一起共享 elements 的記憶體位置。 舉個 Java 的例子， int[] arr1 = {1, 2, 3}; int[] arr2 = arr1; arr2 就是一個 arr1 的 shallow copy。 一旦其中一個 structure 更動了 element 另外一個也會受到影響。 ","date":"2020-01-21","objectID":"/zh-tw/posts/deep-copy-shallow-copy.html:0:1","tags":["Programming"],"title":"Deep Copy and Shallow Copy","uri":"/zh-tw/posts/deep-copy-shallow-copy.html"},{"categories":["Programming"],"content":"Deep Copy 全部複製， Deep copy 出來的 structure 不但有跟舊的 structure 相同的結構， 還把舊的 structure 的 elements 全部複製了一份到新的記憶體空間。 int[] arr1 = {1, 2, 3}; int[] arr2 = new int[arr1.length]; for (int i = 0; i \u003c arr1.length; ++i) { arr2[i] = arr1[i]; } arr2 是 arr1 的 deep copy。 占用的記憶體空間比較多。 ","date":"2020-01-21","objectID":"/zh-tw/posts/deep-copy-shallow-copy.html:0:2","tags":["Programming"],"title":"Deep Copy and Shallow Copy","uri":"/zh-tw/posts/deep-copy-shallow-copy.html"},{"categories":["C++"],"content":"Array 固定大小的連續記憶體空間所構成 ","date":"2020-01-12","objectID":"/zh-tw/posts/c-stl-container-compare-array-vector-dequeue-list-forward_list.html:1:0","tags":["Programming","C++","STL","container"],"title":"C++ STL Containers 比較 - array, vector, deque, list, forward_list","uri":"/zh-tw/posts/c-stl-container-compare-array-vector-dequeue-list-forward_list.html"},{"categories":["C++"],"content":"優缺點 不能像其他 C++ container 那樣動態改變儲存空間的大小 random access 很有效率 (O(1)) ","date":"2020-01-12","objectID":"/zh-tw/posts/c-stl-container-compare-array-vector-dequeue-list-forward_list.html:1:1","tags":["Programming","C++","STL","container"],"title":"C++ STL Containers 比較 - array, vector, deque, list, forward_list","uri":"/zh-tw/posts/c-stl-container-compare-array-vector-dequeue-list-forward_list.html"},{"categories":["C++"],"content":"Vector 可以動態改變儲存空間大小的 array ","date":"2020-01-12","objectID":"/zh-tw/posts/c-stl-container-compare-array-vector-dequeue-list-forward_list.html:2:0","tags":["Programming","C++","STL","container"],"title":"C++ STL Containers 比較 - array, vector, deque, list, forward_list","uri":"/zh-tw/posts/c-stl-container-compare-array-vector-dequeue-list-forward_list.html"},{"categories":["C++"],"content":"底層實作方式 動態的 allocate array， 當目前的 capacity 不夠大的時候就重新 reallocate 一個新的 array 然後把舊的 element 搬過去 實際上的 capacity 會比目前塞進 vector 裡面的 element 數量大 ","date":"2020-01-12","objectID":"/zh-tw/posts/c-stl-container-compare-array-vector-dequeue-list-forward_list.html:2:1","tags":["Programming","C++","STL","container"],"title":"C++ STL Containers 比較 - array, vector, deque, list, forward_list","uri":"/zh-tw/posts/c-stl-container-compare-array-vector-dequeue-list-forward_list.html"},{"categories":["C++"],"content":"優缺點 random access 很有效率 (O(1)) 在尾端加入或刪除 element 相對有效率 在不是尾端的地方加入或刪除 element 比較慢 ","date":"2020-01-12","objectID":"/zh-tw/posts/c-stl-container-compare-array-vector-dequeue-list-forward_list.html:2:2","tags":["Programming","C++","STL","container"],"title":"C++ STL Containers 比較 - array, vector, deque, list, forward_list","uri":"/zh-tw/posts/c-stl-container-compare-array-vector-dequeue-list-forward_list.html"},{"categories":["C++"],"content":"Deque Double-ended queue， 一樣可以動態的改變 container 大小。 不同的 library 實作 deque 的方式可能會不一樣。 ","date":"2020-01-12","objectID":"/zh-tw/posts/c-stl-container-compare-array-vector-dequeue-list-forward_list.html:3:0","tags":["Programming","C++","STL","container"],"title":"C++ STL Containers 比較 - array, vector, deque, list, forward_list","uri":"/zh-tw/posts/c-stl-container-compare-array-vector-dequeue-list-forward_list.html"},{"categories":["C++"],"content":"優缺點 可以當作是在 container 的頭和尾做 insert 和 delete 都一樣很有效率的 vector， 但不保證 elements 都被存在一塊連續記憶體空間 Reallocate 的時候比 vector 有效率 在不是頭或尾端的地方加入或刪除 element 比較慢 random access 很有效率 (O(1)) ","date":"2020-01-12","objectID":"/zh-tw/posts/c-stl-container-compare-array-vector-dequeue-list-forward_list.html:3:1","tags":["Programming","C++","STL","container"],"title":"C++ STL Containers 比較 - array, vector, deque, list, forward_list","uri":"/zh-tw/posts/c-stl-container-compare-array-vector-dequeue-list-forward_list.html"},{"categories":["C++"],"content":"List ","date":"2020-01-12","objectID":"/zh-tw/posts/c-stl-container-compare-array-vector-dequeue-list-forward_list.html:4:0","tags":["Programming","C++","STL","container"],"title":"C++ STL Containers 比較 - array, vector, deque, list, forward_list","uri":"/zh-tw/posts/c-stl-container-compare-array-vector-dequeue-list-forward_list.html"},{"categories":["C++"],"content":"底層實作方式 Doubly-linked list ","date":"2020-01-12","objectID":"/zh-tw/posts/c-stl-container-compare-array-vector-dequeue-list-forward_list.html:4:1","tags":["Programming","C++","STL","container"],"title":"C++ STL Containers 比較 - array, vector, deque, list, forward_list","uri":"/zh-tw/posts/c-stl-container-compare-array-vector-dequeue-list-forward_list.html"},{"categories":["C++"],"content":"優缺點 在任何一個地方 insert, move 或 erase element 都很快 (O(1)) sorting 的時候用起來很方便 往前或往後 iterate 也很快 random access 慢 (O(n)) 占用額外的 memory space 來存 doubly-linked 的資訊 ","date":"2020-01-12","objectID":"/zh-tw/posts/c-stl-container-compare-array-vector-dequeue-list-forward_list.html:4:2","tags":["Programming","C++","STL","container"],"title":"C++ STL Containers 比較 - array, vector, deque, list, forward_list","uri":"/zh-tw/posts/c-stl-container-compare-array-vector-dequeue-list-forward_list.html"},{"categories":["C++"],"content":"Forward_list ","date":"2020-01-12","objectID":"/zh-tw/posts/c-stl-container-compare-array-vector-dequeue-list-forward_list.html:5:0","tags":["Programming","C++","STL","container"],"title":"C++ STL Containers 比較 - array, vector, deque, list, forward_list","uri":"/zh-tw/posts/c-stl-container-compare-array-vector-dequeue-list-forward_list.html"},{"categories":["C++"],"content":"底層實作方式 Singly-linked list ","date":"2020-01-12","objectID":"/zh-tw/posts/c-stl-container-compare-array-vector-dequeue-list-forward_list.html:5:1","tags":["Programming","C++","STL","container"],"title":"C++ STL Containers 比較 - array, vector, deque, list, forward_list","uri":"/zh-tw/posts/c-stl-container-compare-array-vector-dequeue-list-forward_list.html"},{"categories":["C++"],"content":"優缺點 在任何一個地方 insert, move 或 erase element 都很快 (O(1)) sorting 的時候用起來很方便 只能往後 iterate random access 慢 (O(n)) 占用額外的 memory space 來存 singly-linked 的資訊 儲存空間相對 list 來說較少 只能往一個方向 iterate ","date":"2020-01-12","objectID":"/zh-tw/posts/c-stl-container-compare-array-vector-dequeue-list-forward_list.html:5:2","tags":["Programming","C++","STL","container"],"title":"C++ STL Containers 比較 - array, vector, deque, list, forward_list","uri":"/zh-tw/posts/c-stl-container-compare-array-vector-dequeue-list-forward_list.html"},{"categories":["C++"],"content":"Reference http://www.cplusplus.com/reference/array/array/ http://www.cplusplus.com/reference/vector/vector/ http://www.cplusplus.com/reference/deque/deque/ http://www.cplusplus.com/reference/list/list/ http://www.cplusplus.com/reference/forward_list/forward_list/ ","date":"2020-01-12","objectID":"/zh-tw/posts/c-stl-container-compare-array-vector-dequeue-list-forward_list.html:6:0","tags":["Programming","C++","STL","container"],"title":"C++ STL Containers 比較 - array, vector, deque, list, forward_list","uri":"/zh-tw/posts/c-stl-container-compare-array-vector-dequeue-list-forward_list.html"},{"categories":["Docker"],"content":"接上一篇 Docker 操作紀錄 (一) ","date":"2020-01-09","objectID":"/zh-tw/posts/docker-operating-2.html:0:0","tags":["Docker","Virtual Environment"],"title":"Docker 操作紀錄(二)","uri":"/zh-tw/posts/docker-operating-2.html"},{"categories":["Docker"],"content":"Docker 基本使用 ","date":"2020-01-09","objectID":"/zh-tw/posts/docker-operating-2.html:1:0","tags":["Docker","Virtual Environment"],"title":"Docker 操作紀錄(二)","uri":"/zh-tw/posts/docker-operating-2.html"},{"categories":["Docker"],"content":"刪除 Container 記得先用 stop 停止 container 才能刪。 docker rm CONTAINER_NAME 或 docker rm CONTAINER_ID 刪完之後可以用 docker ps -a 確認一下是不是 container 就消失了。 ","date":"2020-01-09","objectID":"/zh-tw/posts/docker-operating-2.html:1:1","tags":["Docker","Virtual Environment"],"title":"Docker 操作紀錄(二)","uri":"/zh-tw/posts/docker-operating-2.html"},{"categories":["Docker"],"content":"用之前 Export 過的 Container 建立 image 之前 export 過一個 container 出來叫 c_test.tar， 可以用它來建立一個新的 image: cat c_test.tar | docker import - ubuntu_test_repo:1.0 後面那個 ubuntu_test_repo 是 repository 的名字， 1.0 是 tag， 可以用 docker images 列出來看一下。 有了 image 就可以建立新的 container 了。 ","date":"2020-01-09","objectID":"/zh-tw/posts/docker-operating-2.html:1:2","tags":["Docker","Virtual Environment"],"title":"Docker 操作紀錄(二)","uri":"/zh-tw/posts/docker-operating-2.html"},{"categories":["Docker"],"content":"刪除 Image 如果我用 docker images 列出的 image 有這些: REPOSITORY TAG IMAGE ID CREATED SIZE aaa 2.0 b30c39fffb75 4 seconds ago 64.2MB aaa 1.0 6b8046192d83 8 seconds ago 64.2MB ubuntu_test_repo 1.0 864c36a752c3 5 hours ago 64.2MB ubuntu latest 549b9b86cb8d 2 weeks ago 64.2MB hello-world latest fce289e99eb9 12 months ago 1.84kB 要刪除 repository 名稱為 aaa， tag 為 1.0 的 image: docker rmi aaa:1.0 就可以了。 所有用這個 image 的 container 要先被 rm 掉。 ","date":"2020-01-09","objectID":"/zh-tw/posts/docker-operating-2.html:1:3","tags":["Docker","Virtual Environment"],"title":"Docker 操作紀錄(二)","uri":"/zh-tw/posts/docker-operating-2.html"},{"categories":["Docker"],"content":"Dockerfile 是一個檔案， 可以讓使用者用更簡單的方式來建立 image。 分成四個部分: Image Maintainer (誰要對這個 dockerfile 負責) 操作 command Container 啟動時的 command 舉一個 nginx 的例子: # 這是 dockerfile 的註解方式 # Image FROM ubuntu # Maintainer MAINTAINER user user@example.com # 操作 command RUN apt-get update \\ \u0026\u0026 apt-get upgrade -y \\ \u0026\u0026 apt-get install -y nginx # Container 啟動時的 command CMD [\"nginx\", \"-g\", \"daemon off;\"] ","date":"2020-01-09","objectID":"/zh-tw/posts/docker-operating-2.html:2:0","tags":["Docker","Virtual Environment"],"title":"Docker 操作紀錄(二)","uri":"/zh-tw/posts/docker-operating-2.html"},{"categories":["Docker"],"content":"建立 Image 可以用 docker build 來建立 image。 把剛剛那個 nginx 的 Dockerfile 放在 /tmp/d_file 下， 名稱叫 test_d_file 要 build 成 image， 並給那個 image 一個 test-nginx-img/1.0 的 tag: docker build -t test-nginx-img/1.0 -f /tmp/d_file/test_d_file . build 完之後用 docker images 看一下: REPOSITORY TAG IMAGE ID CREATED SIZE test-nginx-img/1.0 latest 7293588d00a9 27 seconds ago 152MB ","date":"2020-01-09","objectID":"/zh-tw/posts/docker-operating-2.html:3:0","tags":["Docker","Virtual Environment"],"title":"Docker 操作紀錄(二)","uri":"/zh-tw/posts/docker-operating-2.html"},{"categories":["Docker"],"content":"Reference Docker docs ","date":"2020-01-09","objectID":"/zh-tw/posts/docker-operating-2.html:4:0","tags":["Docker","Virtual Environment"],"title":"Docker 操作紀錄(二)","uri":"/zh-tw/posts/docker-operating-2.html"},{"categories":["Web Hosting"],"content":"設計比較大流量的系統時早晚要遇上 cluster 的問題。 ","date":"2020-01-09","objectID":"/zh-tw/posts/ha-cluster-app-architecture.html:0:0","tags":["Cluster","High availability","Architecture"],"title":"HA cluster 筆記和 Application 設計","uri":"/zh-tw/posts/ha-cluster-app-architecture.html"},{"categories":["Web Hosting"],"content":"Cluster 一台以上的機器(node)組成的集合， 有三種不同的目的: ","date":"2020-01-09","objectID":"/zh-tw/posts/ha-cluster-app-architecture.html:1:0","tags":["Cluster","High availability","Architecture"],"title":"HA cluster 筆記和 Application 設計","uri":"/zh-tw/posts/ha-cluster-app-architecture.html"},{"categories":["Web Hosting"],"content":"Load Balancing 讓多台機器一起盡可能的平均分擔任務， 加速應用程式執行。 ","date":"2020-01-09","objectID":"/zh-tw/posts/ha-cluster-app-architecture.html:1:1","tags":["Cluster","High availability","Architecture"],"title":"HA cluster 筆記和 Application 設計","uri":"/zh-tw/posts/ha-cluster-app-architecture.html"},{"categories":["Web Hosting"],"content":"High Availability (HA) 為了高可用性和備援， 如果其中一台機器突然掛了其他的機器可以接替。 ","date":"2020-01-09","objectID":"/zh-tw/posts/ha-cluster-app-architecture.html:1:2","tags":["Cluster","High availability","Architecture"],"title":"HA cluster 筆記和 Application 設計","uri":"/zh-tw/posts/ha-cluster-app-architecture.html"},{"categories":["Web Hosting"],"content":"High Performance Computing 高效能/平行運算系統， 簡稱 HPC cluster， 結合多台機器的硬體來增加運算能力， 用來解決單一一台機器不能解決的任務。 ","date":"2020-01-09","objectID":"/zh-tw/posts/ha-cluster-app-architecture.html:1:3","tags":["Cluster","High availability","Architecture"],"title":"HA cluster 筆記和 Application 設計","uri":"/zh-tw/posts/ha-cluster-app-architecture.html"},{"categories":["Web Hosting"],"content":"HA 運作模式 有很多種例如 N+1, N+M, … 但最常見的是 two-node cluster， two-node cluster 有兩種運作方式: Active-Passive Active-Acitve ","date":"2020-01-09","objectID":"/zh-tw/posts/ha-cluster-app-architecture.html:2:0","tags":["Cluster","High availability","Architecture"],"title":"HA cluster 筆記和 Application 設計","uri":"/zh-tw/posts/ha-cluster-app-architecture.html"},{"categories":["Web Hosting"],"content":"Active-Passive (AP) Master-slave 的設計， 正常狀況下只有 master (Active) 在做 service， 當 master (Active) 出現問題時 slave (Passive) 才接手， 等到 master (Active) 恢復正常狀態再換回來由 master (Active) 繼續處理 service 優點: Fail-over 的速度快 設計跟設定都相對簡單 缺點: 沒辦法同時做 load balance 會浪費一些硬體 ","date":"2020-01-09","objectID":"/zh-tw/posts/ha-cluster-app-architecture.html:2:1","tags":["Cluster","High availability","Architecture"],"title":"HA cluster 筆記和 Application 設計","uri":"/zh-tw/posts/ha-cluster-app-architecture.html"},{"categories":["Web Hosting"],"content":"Active-Active (AA) 兩台機器都同時有自己獨立執行的 service (都同時是 Active)， 同時也互相備援 (當對方的 Passive)， 當其中一台出現問題時另一台接手他的 service。 優點: 正常運作的時候兩台機器都沒有閒置， 運作效益高 缺點: Fail-over 之後機器的負擔變大， 速度變慢 設計設定相對複雜 ","date":"2020-01-09","objectID":"/zh-tw/posts/ha-cluster-app-architecture.html:2:2","tags":["Cluster","High availability","Architecture"],"title":"HA cluster 筆記和 Application 設計","uri":"/zh-tw/posts/ha-cluster-app-architecture.html"},{"categories":["Web Hosting"],"content":"Application Design 需要有相對簡單的方法來 start, stop, force-stop service 和檢查 service 目前的狀態。 =\u003e 設計 application 的時候要有 command line interface 或 script 能夠做到這點 =\u003e 兩台機器上的 service 要互相可以知道對方狀態跟發生意外的時候要能啟動 or 停止 需要有 shared storage， 而且 Application 要能將自己的狀態盡量仔細的紀錄到 shared storage。 =\u003e 兩台機器切換的時候才不會少東西 要能 restart 另一個 node 並恢復到 failure 發生前的狀態 =\u003e 恢復 failure 前的狀態可以用存到 shared storage 的狀態來做 當 application crash 的時候不能毀損存到 shared storage 上的資料 =\u003e 另外一邊要用 ","date":"2020-01-09","objectID":"/zh-tw/posts/ha-cluster-app-architecture.html:3:0","tags":["Cluster","High availability","Architecture"],"title":"HA cluster 筆記和 Application 設計","uri":"/zh-tw/posts/ha-cluster-app-architecture.html"},{"categories":["Web Hosting"],"content":"Remark Application upgrade 時會發生的狀況要考慮進去 有些 SQL 或 noSQL 本身有支援這類的設定可以採用可以減少不少麻煩 ","date":"2020-01-09","objectID":"/zh-tw/posts/ha-cluster-app-architecture.html:3:1","tags":["Cluster","High availability","Architecture"],"title":"HA cluster 筆記和 Application 設計","uri":"/zh-tw/posts/ha-cluster-app-architecture.html"},{"categories":["Web Hosting"],"content":"DNS server 中每個 DNS zone 都有一個 zone file， DNS zone 通常會是一個 single domain (有時候不是)， zone file 是由很多個 dns resource record (RR) 組成， RR 有很多種不同的類型， 紀錄一下常用幾種。 ","date":"2020-01-08","objectID":"/zh-tw/posts/common-dns-resource-record.html:0:0","tags":["DNS"],"title":"常用 DNS Resource Record 紀錄","uri":"/zh-tw/posts/common-dns-resource-record.html"},{"categories":["Web Hosting"],"content":"A record 將 hostname 對應到 IPv4。 (32-bit) hostname IN A xxx.xxx.xxx.xxx ","date":"2020-01-08","objectID":"/zh-tw/posts/common-dns-resource-record.html:1:0","tags":["DNS"],"title":"常用 DNS Resource Record 紀錄","uri":"/zh-tw/posts/common-dns-resource-record.html"},{"categories":["Web Hosting"],"content":"AAAA record 將 hostname 對應到 IPv6。 (128-bit) hostname IN AAAA xxxx:xxxx:xxxx:xxxx:xxxx:xxxx:xxxx:xxxx ","date":"2020-01-08","objectID":"/zh-tw/posts/common-dns-resource-record.html:2:0","tags":["DNS"],"title":"常用 DNS Resource Record 紀錄","uri":"/zh-tw/posts/common-dns-resource-record.html"},{"categories":["Web Hosting"],"content":"CNAME record 為 hostname 設立的別名。 alias IN CNAME hostname 注意 alias 不能再有其他 A record 或 MX record。 ","date":"2020-01-08","objectID":"/zh-tw/posts/common-dns-resource-record.html:3:0","tags":["DNS"],"title":"常用 DNS Resource Record 紀錄","uri":"/zh-tw/posts/common-dns-resource-record.html"},{"categories":["Web Hosting"],"content":"MX record Mail exchanger record。 Email server 的 domain name, priority 和 hostname。 注意是 hostname 而不是直接是 IP， 也不能是 cname 的 alias， 所以 IP 還要另外多設一個 RR。(A 或 AAAA record) Priority 數字越低代表優先權越高 (先傳送到優先權高的)。 mail_domain_name IN MX priority hostname 例子， example.com. IN MX 10 mailserver.example.com","date":"2020-01-08","objectID":"/zh-tw/posts/common-dns-resource-record.html:4:0","tags":["DNS"],"title":"常用 DNS Resource Record 紀錄","uri":"/zh-tw/posts/common-dns-resource-record.html"},{"categories":["Database"],"content":"RDBMS Relational Database Management System 在資料之前有很強的 Relation (關聯性) 的時候使用: 設計不太會去變動的 schema 將 table 互相關聯， 就可以去透過 SQL 取得想要的資料 資料的正確性很重要的時候使用 通常會提供ACID 要變動 schema 是一件很浩大的工程: 要把的 table 的 schema 更新還要 migrate 資料 所有用到要被更換 schema 的 table 的程式都要修改 Vertical scaling 效果比較明顯 (提升機器的性能) ","date":"2020-01-06","objectID":"/zh-tw/posts/rdbms-acid-nosql-cap.html:1:0","tags":["Database","NoSQL","RDBMS"],"title":"RDBMS 與 NoSQL 差異筆記","uri":"/zh-tw/posts/rdbms-acid-nosql-cap.html"},{"categories":["Database"],"content":"ACID 通常 RDBMS 會保證交易(transaction)有四種特性: Atomicity 只有 全部做完(Commit) 跟 全部沒做(Abort) 兩種可能， 沒有做了一半這種狀態 如果執行中有 error 的話就是 Rollback 成全部沒做的狀態 Consistency 交易前後 database 都會保持合法的狀態。 Isolation 多筆 transaction 都要執行時每筆 transaction 都是分開的不會互相干擾。 A 和 B 做交易不影響 B 和 C 做交易。 Durability Transaction 做完了就是永久有效的不會失效， 就算系統突然壞了也一樣。 ","date":"2020-01-06","objectID":"/zh-tw/posts/rdbms-acid-nosql-cap.html:1:1","tags":["Database","NoSQL","RDBMS"],"title":"RDBMS 與 NoSQL 差異筆記","uri":"/zh-tw/posts/rdbms-acid-nosql-cap.html"},{"categories":["Database"],"content":"NoSQL Not only SQL 比較不在意資料之間的 Relation 存取資料時不需要固定的 schema 每筆資料單獨存在沒有誰關聯誰的問題 比較在意資料的內容 是否需要更新、新增、刪除等等 資料可以有不同的格式 比較適合分散式系統 通常提供 CAP 其中兩種 Horizontal scaling 效果比較明顯 (多找幾台機器) ","date":"2020-01-06","objectID":"/zh-tw/posts/rdbms-acid-nosql-cap.html:2:0","tags":["Database","NoSQL","RDBMS"],"title":"RDBMS 與 NoSQL 差異筆記","uri":"/zh-tw/posts/rdbms-acid-nosql-cap.html"},{"categories":["Database"],"content":"CAP 對一個分散式系統來說， CAP 三種特性不可能都能保證存在(但有可能同時存在，網路很順的時候)， 頂多同時能保證存在兩種。 Consistency 每次 read 如果不是得到 error 都會讀到最近一次寫入的結果。 =\u003e 每個 node 的 data 都是一樣的 Availability 每個 request 都會得到一個不是 error 的 response， 不管這個 response 回傳的資料是不是最新的。 =\u003e 怎麼樣都保證資料會被回傳，不過資料可能是舊的 Partition tolerance 就算有些在 node 之間傳送的訊息被 delay 或是掉了系統也會繼續運作。 =\u003e 網路有狀況的時候，正常連線的那一部份 node 可以正常運行。 ","date":"2020-01-06","objectID":"/zh-tw/posts/rdbms-acid-nosql-cap.html:2:1","tags":["Database","NoSQL","RDBMS"],"title":"RDBMS 與 NoSQL 差異筆記","uri":"/zh-tw/posts/rdbms-acid-nosql-cap.html"},{"categories":["Database"],"content":"Reference Wiki ACID Wiki CAP ","date":"2020-01-06","objectID":"/zh-tw/posts/rdbms-acid-nosql-cap.html:3:0","tags":["Database","NoSQL","RDBMS"],"title":"RDBMS 與 NoSQL 差異筆記","uri":"/zh-tw/posts/rdbms-acid-nosql-cap.html"},{"categories":["Operating System"],"content":"為了弄清楚某個 daemon 的東西， 決定把 daemon 是什麼弄清楚， 網路上找到的資料實在又多又不清楚， 乾脆直接從 The Linux Programming Interface 把相關資料找出來做筆記。 Process group 是一堆 related processes 組成的集合 Session 是一堆 related process groups 組成的集合 Process group 和 Session 的定義是為了方便做 job control。 ","date":"2020-01-02","objectID":"/zh-tw/posts/linux-process-group-sessions-daemon.html:0:0","tags":["Linux","OS"],"title":"Process Groups, Sessions and Daemon Overview","uri":"/zh-tw/posts/linux-process-group-sessions-daemon.html"},{"categories":["Operating System"],"content":"Process Group 一堆 related processes 共享相同的 process group identifier (PGID)。 這群 process 裡面會有一個 process group leader 是建立這個 process group 的 process， 這個 process group leader 的 PID 就會是這個 process group 的 PGID。 任何一個新的 process 被建立出來的時候， 他的 PGID 就會是他的 parent 的 PGID。 Process group 的 lifetime 是從 process group leader 建立這個 process group 開始算， 一直到所有在這個 process group 的 process 都離開這個 process group。 (有可能是 process 做完結束了， 或是 process 變換到了別的 process group) ","date":"2020-01-02","objectID":"/zh-tw/posts/linux-process-group-sessions-daemon.html:1:0","tags":["Linux","OS"],"title":"Process Groups, Sessions and Daemon Overview","uri":"/zh-tw/posts/linux-process-group-sessions-daemon.html"},{"categories":["Operating System"],"content":"Session 一群 related process groups 共享相同的 session identifier (SID)。 這群 process group 裡面有一個 session leader 是建立這個 session 的 process， session leader 的 PID 就會是這個 session 的 SID。 任何一個新的 process 被建立出來的時候， 他的 SID 會是他的 parent 的 SID。 所有在同一個 session 裡的 process 都會共享一個controlling terminal， 一個 controlling terminal 會在 session leader 第一次開啟一個 terminal device 的時候建立， 而一個 terminal 只能當一個 session 的 controlling terminal。 =\u003e session 和 controlling terminal 是一對一的關係 在任一時間點會有： foreground process group: 在 session 中的一組 porcess group， 只有這個 process group 裡面的 process 才能讀取從 controlling terminal 來的 input。 background process groups: 其他不是 foreground process group 的所有 process group， ","date":"2020-01-02","objectID":"/zh-tw/posts/linux-process-group-sessions-daemon.html:2:0","tags":["Linux","OS"],"title":"Process Groups, Sessions and Daemon Overview","uri":"/zh-tw/posts/linux-process-group-sessions-daemon.html"},{"categories":["Operating System"],"content":"Terminal 運作 流程大概是： 開啟一個 terminal 的時候會有一個 session leader 會是 controlling process， 會有一組 foreground process group 等著接從 terminal 讀取的東西， 有可能是 user input 或是 user 給的 signal， 同時也會有一些 background process groups 存在。 當 terminal 結束的時候 kernel 會送 SIGHUP 給 session leader 通知他這個 terminal 結束了。 ","date":"2020-01-02","objectID":"/zh-tw/posts/linux-process-group-sessions-daemon.html:3:0","tags":["Linux","OS"],"title":"Process Groups, Sessions and Daemon Overview","uri":"/zh-tw/posts/linux-process-group-sessions-daemon.html"},{"categories":["Operating System"],"content":"Shell Job Control Process groups 和 session 主要是用來做 shell job control， 舉一個登入的例子： 使用者 login 用的那個 terminal 就是 controlling terminal， 而 login shell 就是 session leader 同時也是這個 terminal 的 controlling process， 從這個 shell 開始的所有 command 會建立出一個以上的 processes， 這些 processes 會變成新的 process groups， 從這些 process 再建立的新的 process 就會是那個建立他的 process 的 process group 的一份子。 所有這些 process 都從這個 shell 建立， 所以都屬於這個 login session。 ","date":"2020-01-02","objectID":"/zh-tw/posts/linux-process-group-sessions-daemon.html:4:0","tags":["Linux","OS"],"title":"Process Groups, Sessions and Daemon Overview","uri":"/zh-tw/posts/linux-process-group-sessions-daemon.html"},{"categories":["Operating System"],"content":"Daemon Daemon 具有的特性： long-lived: 通常是在系統啟動的時候跟著啟動開始運作， 一直到系統關機才結束。 跑在 background 而且不具有 controlling terminal: 確保 kernel 不會自動產生 job control 或 terminal 相關的 signal 去影響到 daemon。 通常 daemon 會用 ’d’ 結尾。 幾個常見的 daemon: cron sshd httpd ","date":"2020-01-02","objectID":"/zh-tw/posts/linux-process-group-sessions-daemon.html:5:0","tags":["Linux","OS"],"title":"Process Groups, Sessions and Daemon Overview","uri":"/zh-tw/posts/linux-process-group-sessions-daemon.html"},{"categories":["Docker"],"content":"Docker 基本概念 一言以蔽之， 簡化版的 VM。 因為 docker 不會把整個 operating system 都裝起來， 所以大小比 VM 小很多速度也比 VM 快很多。 ","date":"2020-01-01","objectID":"/zh-tw/posts/docker-operating-1.html:1:0","tags":["Docker","Virtual Environment"],"title":"Docker Notes 1 - Beginner","uri":"/zh-tw/posts/docker-operating-1.html"},{"categories":["Docker"],"content":"Image 跑在 container 上面的東西， 裡面包了一個輕量級的 runtime environment， 包含一些 library 跟 executable。 可以想像成 VM 上的 .iso， 只能被讀。 要改的話就是產生一個新的 image。 ","date":"2020-01-01","objectID":"/zh-tw/posts/docker-operating-1.html:1:1","tags":["Docker","Virtual Environment"],"title":"Docker Notes 1 - Beginner","uri":"/zh-tw/posts/docker-operating-1.html"},{"categories":["Docker"],"content":"Container 真的把 image 拿來跑起來的東西， 就是把 image 拿來真的啟動放到 memory 去執行， 跟 VM 一樣和 host environment 是完全隔離的， 除非經過特別設定否則對 container 做什麼跟 host environment 都沒有什麼關係， 例如說可以在 container 上把 port 開起來也不會影響到 host， 但有需要的話也可以設定。 ","date":"2020-01-01","objectID":"/zh-tw/posts/docker-operating-1.html:1:2","tags":["Docker","Virtual Environment"],"title":"Docker Notes 1 - Beginner","uri":"/zh-tw/posts/docker-operating-1.html"},{"categories":["Docker"],"content":"Repository 放 Image 的地方。 可以拿 Git 的 Repository 做比喻， Git 會有很多 repository， 每個 Repository 是拿來放一個專案的 code 的集合， Docker 所謂的 repository 也是一樣， Repository 是拿來放 image 的地方， 通常在同一個 repository 的 image 會有一樣的名字但不一樣的 tag。 所以也會有很多不同的 repository。 ","date":"2020-01-01","objectID":"/zh-tw/posts/docker-operating-1.html:1:3","tags":["Docker","Virtual Environment"],"title":"Docker Notes 1 - Beginner","uri":"/zh-tw/posts/docker-operating-1.html"},{"categories":["Docker"],"content":"Registry 也是放 image 的地方。 和 repository 不同的是， registry 是一種服務， 可以讓大家把 image 放上去或拉回自己的機器， 用 Git 來比喻就是像 Github。 最有名的就是 Docker Hub。 ","date":"2020-01-01","objectID":"/zh-tw/posts/docker-operating-1.html:1:4","tags":["Docker","Virtual Environment"],"title":"Docker Notes 1 - Beginner","uri":"/zh-tw/posts/docker-operating-1.html"},{"categories":["Docker"],"content":"Docker 基本使用 ","date":"2020-01-01","objectID":"/zh-tw/posts/docker-operating-1.html:2:0","tags":["Docker","Virtual Environment"],"title":"Docker Notes 1 - Beginner","uri":"/zh-tw/posts/docker-operating-1.html"},{"categories":["Docker"],"content":"Install 在 Ubuntu 很簡單， sudo apt-get install docker.io ","date":"2020-01-01","objectID":"/zh-tw/posts/docker-operating-1.html:2:1","tags":["Docker","Virtual Environment"],"title":"Docker Notes 1 - Beginner","uri":"/zh-tw/posts/docker-operating-1.html"},{"categories":["Docker"],"content":"Pull Image 官方 Docker Hub， 有很多 Image 可以抓， 例如我想要一個乾淨無汙染的 Ubuntu 環境， 就可以用 command 來抓一個 Ubuntu 的 image 回自己的機器 (host machine): docker pull ubuntu 或者要指定某一個 tag: docker pull ubuntu:14.04 ","date":"2020-01-01","objectID":"/zh-tw/posts/docker-operating-1.html:2:2","tags":["Docker","Virtual Environment"],"title":"Docker Notes 1 - Beginner","uri":"/zh-tw/posts/docker-operating-1.html"},{"categories":["Docker"],"content":"Run the Image 可以用剛剛 pull 下來的 Ubuntu echo 一個 Hello World: docker run ubuntu /bin/echo 'Hello world' 應該會跳出一行 Hello world。 這裡只是測試一下 Image， docker run 建立了一個暫時的 Container， 跑完 hello world 以後 container 就結束了。 ","date":"2020-01-01","objectID":"/zh-tw/posts/docker-operating-1.html:2:3","tags":["Docker","Virtual Environment"],"title":"Docker Notes 1 - Beginner","uri":"/zh-tw/posts/docker-operating-1.html"},{"categories":["Docker"],"content":"列出 Local 有哪些 Images docker images 應該會出現剛剛裝過的那個 Ubuntu。 ","date":"2020-01-01","objectID":"/zh-tw/posts/docker-operating-1.html:2:4","tags":["Docker","Virtual Environment"],"title":"Docker Notes 1 - Beginner","uri":"/zh-tw/posts/docker-operating-1.html"},{"categories":["Docker"],"content":"Create 一個 Container Container 被開出來就是可以被改變的東西了!! 用 image 建一個 container 就好像用 .iso 裝到 VM 裡。 用剛剛有的 ubuntu 那個 image 來建一個 container: docker create -it ubuntu 也可以建立一個有名字的 Container: docker create -it --name CONTAINER_NAME ubuntu i 是指 input (讓 container 的 stdin 打開)， t 是指 tty (有個 terminal 可以用)。 或者如果要讓 Container 被 create 而且直接被啟動開始跑: docker run -itd ubuntu 或 docker run -itd --name CONTAINER_NAME ubuntu d 是指 detach (讓 container 跑在 background)。 ","date":"2020-01-01","objectID":"/zh-tw/posts/docker-operating-1.html:2:5","tags":["Docker","Virtual Environment"],"title":"Docker Notes 1 - Beginner","uri":"/zh-tw/posts/docker-operating-1.html"},{"categories":["Docker"],"content":"列出有哪些 Container docker ps -a 可以列出所有現在 host 上有的 container， 應該會出現前面用 Ubuntu image 建立起來的 Container。 可以看到 docker create 和 docker run 建立的 Container 的 status 會不一樣， docker create 只有建立了這個 container 還沒有啟動他， 所以 status 會是 created； 而 docker run 已經直接讓 container 被建立也被啟動了， 所以 status 會是 Up。 最前面有個 container id， 要去 run 這個 container 的時候可能會用到。 ","date":"2020-01-01","objectID":"/zh-tw/posts/docker-operating-1.html:2:6","tags":["Docker","Virtual Environment"],"title":"Docker Notes 1 - Beginner","uri":"/zh-tw/posts/docker-operating-1.html"},{"categories":["Docker"],"content":"啟動並進入 Container 如果是用 docker create 建立的 container 要先被啟動才能進入: 可以用 container id 來啟動 container: docker start \"CONTAINER_ID\" 或者如果建立 Container 有指定名字， 也可以用 container 的名字 來啟動 container: docker start \"CONTAINER_NAME\" 當 container 的 status 是 exit 時就需要先被 start 啟動才能對 container 做後續的改動。 可以先用 docker ps -a 看一下 status。 已經被 docker run 啟動過先 run 在 background 的 container， 或是以敬備 docker start 啟動的 container 都可以用 docker exec 進入: docker exec -it \"CONTAINER_ID\" bash bash 是要執行的 command， 也可以用 docker exec 執行其他的 command 如 echo 等。 如果 container 有名字也能直接用 container 的名字進入 container docker exec -it \"CONTAINER_NAME\" bash 應該會發現已經進入到 Container 了， 使用者會變成 Container 的 root， 可以開始在這個 Container 上面做設定或裝東西。 要離開 Container 環境的時候打個 exit 就好。 離開以後 Container 依然會在 background 跑。 ","date":"2020-01-01","objectID":"/zh-tw/posts/docker-operating-1.html:2:7","tags":["Docker","Virtual Environment"],"title":"Docker Notes 1 - Beginner","uri":"/zh-tw/posts/docker-operating-1.html"},{"categories":["Docker"],"content":"停止 Container 就跟把 VM 關機差不多意思， 讓 container 變成未啟動的狀態， 讓 container 的 status 變成 exit。 也是要用到 container id 或名字， docker stop \"CONTAINER_ID\" 或 docker stop \"CONTAINER_NAME\" 如果這個時候再用 docker ps -a 看一下， 可以發現 status 會變成 Exited。 ","date":"2020-01-01","objectID":"/zh-tw/posts/docker-operating-1.html:2:8","tags":["Docker","Virtual Environment"],"title":"Docker Notes 1 - Beginner","uri":"/zh-tw/posts/docker-operating-1.html"},{"categories":["Docker"],"content":"Export Container 就可以把 Container export 出來變成 .tar檔搬到別的主機上， 也是要用到 container id 或 container name。 假設要把 container export 出來變成 exported.tar: docker export \"CONTAINER_ID\" \u003e exported.tar 或 docker export \"CONTAINER_NAME\" \u003e exported.tar 就能夠壓出一個 .tar 檔把 container 搬去別的主機。 ","date":"2020-01-01","objectID":"/zh-tw/posts/docker-operating-1.html:2:9","tags":["Docker","Virtual Environment"],"title":"Docker Notes 1 - Beginner","uri":"/zh-tw/posts/docker-operating-1.html"},{"categories":["Docker"],"content":"Reference Docker docs ","date":"2020-01-01","objectID":"/zh-tw/posts/docker-operating-1.html:3:0","tags":["Docker","Virtual Environment"],"title":"Docker Notes 1 - Beginner","uri":"/zh-tw/posts/docker-operating-1.html"},{"categories":["Blog"],"content":"更新 已從 Jekyll migrate 到 Hugo， 這篇方法僅適用 Jekyll。 ","date":"2019-12-30","objectID":"/zh-tw/posts/jekyll-sitemap-github-pages.html:1:0","tags":["Programming","Jekyll","SEO","Github Pages"],"title":"Github Pages and Jekyll - sitemap","uri":"/zh-tw/posts/jekyll-sitemap-github-pages.html"},{"categories":["Blog"],"content":"Sitemap sitemap 基本上就一個 .xml 檔案， 裡面包含了網站有哪些頁面連結， 讓搜尋引擎去爬， 搜尋引擎爬完以後就可以建立 index， 之後有人在搜尋引擎打關鍵字才搜尋的到。 ","date":"2019-12-30","objectID":"/zh-tw/posts/jekyll-sitemap-github-pages.html:2:0","tags":["Programming","Jekyll","SEO","Github Pages"],"title":"Github Pages and Jekyll - sitemap","uri":"/zh-tw/posts/jekyll-sitemap-github-pages.html"},{"categories":["Blog"],"content":"Jekyll-sitemap Jekyll 有一個 plugin 叫做 jekyll-stiemap， 可以在每次 build 網站之後自動產生 sitemap。 如果是自己的機器架站的話其實是個不錯的選擇， 一開始我在 Github Page 用 Jekyll 建 Blog 也是用這個， 但後來發現不曉得究竟是版本問題還是因為 Github Pages 在 build 網站的時候用的是不同的方法或參數， sitemap 是生出來了沒有錯， 但是網址前段的部分因為莫名其妙的原因被吃掉了。 ","date":"2019-12-30","objectID":"/zh-tw/posts/jekyll-sitemap-github-pages.html:3:0","tags":["Programming","Jekyll","SEO","Github Pages"],"title":"Github Pages and Jekyll - sitemap","uri":"/zh-tw/posts/jekyll-sitemap-github-pages.html"},{"categories":["Blog"],"content":"自己生 sitemap 最後只好 Google 一下看看有沒有人是自己生 sitemap 的， 就找到了這個， 似乎可以 work， 於是直接抓來改， 然後放到 repository 的 sitemap.xml， build 完之後檢查一下沒有問題就成功了。 ","date":"2019-12-30","objectID":"/zh-tw/posts/jekyll-sitemap-github-pages.html:4:0","tags":["Programming","Jekyll","SEO","Github Pages"],"title":"Github Pages and Jekyll - sitemap","uri":"/zh-tw/posts/jekyll-sitemap-github-pages.html"},{"categories":["C++"],"content":"const 和一般變數 有兩種寫法 const TYPE NAME = VALUE; // more common TYPE const NAME = VAULE; 意思都一樣， 就是這個變數不能再被指定別的值。 舉個例： #include \u003ciostream\u003e using namespace std; int main(void) { const int i = 1; int const j = 1; i = 2; // error j = 2; // error cout \u003c\u003c \"i = \" \u003c\u003c i \u003c\u003c endl; cout \u003c\u003c \"j = \" \u003c\u003c j \u003c\u003c endl; return 0; } i和j兩個噴的 error 一模一樣: const.cpp:9:4: error: cannot assign to variable 'i' with const-qualified type 'const int' i = 2; ~ ^ const.cpp:7:12: note: variable 'i' declared const here const int i = 1; ~~~~~~~~~~^~~~~ const.cpp:10:4: error: cannot assign to variable 'j' with const-qualified type 'const int' j = 2; ~ ^ const.cpp:8:12: note: variable 'j' declared const here int const j = 1; ~~~~~~~~~~^~~~~ 2 errors generated. ","date":"2019-12-30","objectID":"/zh-tw/posts/const-pointer-reference.html:1:0","tags":["Programming","C","C++"],"title":"C/C++ - const 加上 pointer 和 reference 的用法整理","uri":"/zh-tw/posts/const-pointer-reference.html"},{"categories":["C++"],"content":"const 和 reference 跟一般變數一樣有兩種寫法: const TYPE \u0026NAME = VALUE; // more common TYPE const \u0026NAME = VAULE; 意思也一樣， 有兩個限制: Reference 不能再拿去指定別的變數 被 reference 指到的變數不能用 reference 去指定別的值。 不過他可以在不透過 reference 的情況下自己改變他的值。 例子: #include \u003ciostream\u003e using namespace std; int main(void) { int i = 1, j = 2; int const \u0026r1 = i; const int \u0026r2 = i; // change value with reference r1 = 3; // error r2 = 3; // error // change value i = 4; // change reference object r1 = j; // error r2 = j; // error return 0; } constant reference 唯一能做的就是拿來讀， 要改值的話只能是他 reference 到的變數不透過 reference 自己改自己。 ","date":"2019-12-30","objectID":"/zh-tw/posts/const-pointer-reference.html:2:0","tags":["Programming","C","C++"],"title":"C/C++ - const 加上 pointer 和 reference 的用法整理","uri":"/zh-tw/posts/const-pointer-reference.html"},{"categories":["C++"],"content":"const 和 pointer 這就複雜了， 可以用 const 的位置來記 const 是用來修飾誰: TYPE* const pNAME; // 1 TYPE const *pNAME; // 2 const TYPE *pNAME; // 3 const TYPE* const pNAME; // 4 1 的情況下 const 修飾的是 pNAME， 也就是 pNAME 不能再被改變 (不能 pNAME = ...)； 2 的情況 const 修飾的是 *pNAME， 是說 *pNAME 不能再被改變 (不能 *pNAME = ...)； 3 的情況 const 修飾的是 TYPE *pNAME， 跟 2 一樣是說 *pNAME 不能再被改變 (不能 *pNAME = ...)； 4 的情況 const 修飾的是 pNAME 和 TYPE*， 所以 pNAME 和 TYPE* 都不能改變 (pNAME = ... 和 *pNAME = ... 都不行)。 #include \u003ciostream\u003e using namespace std; int main(void) { int i = 1, j = 2; int* const p1 = \u0026i; int const *p2 = \u0026i; const int *p3 = \u0026i; const int* const p4 = \u0026i; // change value with pointer *p1 = 2; *p2 = 2; // error *p3 = 2; // error *p4 = 2; // error // change value i = 3; // change pointer position p1 = \u0026j; // error p2 = \u0026j; p3 = \u0026j; p4 = \u0026j; // error return 0; }","date":"2019-12-30","objectID":"/zh-tw/posts/const-pointer-reference.html:3:0","tags":["Programming","C","C++"],"title":"C/C++ - const 加上 pointer 和 reference 的用法整理","uri":"/zh-tw/posts/const-pointer-reference.html"},{"categories":["Blog"],"content":"更新 已從 Jekyll migrate 到 Hugo， 這篇方法原理不變但 code 放的位置和內容要修正。 ","date":"2019-12-27","objectID":"/zh-tw/posts/likecoin-button-jekyll.html:1:0","tags":["Likecoin","Frontend","Github Pages"],"title":"Add LikeWidget to Jekyll theme","uri":"/zh-tw/posts/likecoin-button-jekyll.html"},{"categories":["Blog"],"content":"LikeCoin 前陣子對 LikeCoin 發生了一點興趣， LikeCoin 是一種虛擬貨幣， 創立的初衷是想做為一種獎勵創作者的機制， 創作者在文章裡放入 Like Button， 讓大家對他的按鈕按讚鼓掌， 他就能收到相對的 LikeCoin。 至於作者能獲得多少 LikeCoin 就要看按讚讀者的帳戶種類， 如果讀者註冊的是免費帳戶， 那點下的讚就由 LikeCoin 的基金會按比例支付; 如果讀者註冊的是付費帳戶， 那就看該讀者當月按下多少讚按比例分配。 詳情可以參考 LikeCoin 的 Medium。 ","date":"2019-12-27","objectID":"/zh-tw/posts/likecoin-button-jekyll.html:2:0","tags":["Likecoin","Frontend","Github Pages"],"title":"Add LikeWidget to Jekyll theme","uri":"/zh-tw/posts/likecoin-button-jekyll.html"},{"categories":["Blog"],"content":"在 Jekyll Theme 加入 Like Rewords Button 因為看起來很有趣的樣子所以我就註冊了一個帳號， 然後默默的發現 Like Button 的 Widget 有支援 Medium, WordPress, Oice, Matters, …等等等等， 但是因為 Jekyll theme 要怎麼設計完全是看個人， 所以只能自己想辦法加。 於是我只好去 Medium 隨便找了個有加 Like Button 的文章， 把 Firefox 的 Developer Console 打開觀察了一下: 原來是用 iframe， src 的網址看起來直接把黑筆塗掉的地方替換成自己的 liker ID 跟文章網址應該就能 Work 了。 所以要把 Like Button 加到 blog post 裡有兩種方法: 把 iframe 加到 blog post 把 iframe 加到產生 blog post 的 template html 顯然第二種方法比較好， 只要加一次之後所有的 blog post 在產生的時候就可以自己生出 Like Button。 我用的 jekyll theme 產生 blog post 的 template html 放在 _layouts/post.html， 所以我就在放 content 的地方的最後面加上了： \u003cdiv align=\"center\"\u003e \u003ciframe scrolling=\"no\" src=\"https://button.like.co/in/embed/\u003cMY_LIKER_ID\u003e/button/?referrer={{ site.url }}{{ page.url }}\" frameborder=\"0\"\u003e\u003c/iframe\u003e \u003c/div\u003e Liker ID 要換成自己的 Liker ID， site.url 和 page.url 是 Liquid 的語法， 代表的是當下的那篇 blog post 的網址， 加完之後之後每篇 blog post 都會自己產生一個 Like button 了。 ","date":"2019-12-27","objectID":"/zh-tw/posts/likecoin-button-jekyll.html:3:0","tags":["Likecoin","Frontend","Github Pages"],"title":"Add LikeWidget to Jekyll theme","uri":"/zh-tw/posts/likecoin-button-jekyll.html"},{"categories":["Git"],"content":"每當建立一個新的資料夾並在裡面放了一些檔案， MacOS 就會在該資料夾下自動產生一個 .DS_Store 檔案， 也就導致了 .DS_Store 在 macOS 裡面散的到處都是。 而每次有新的 Git repository 就一定要在 .gitignore 裡加 .DS_Store 和 **/.DS_Store 實在是很煩人， 所以就研究了一下找了個辦法一次設定好之後就能夠一勞永逸。 ","date":"2019-12-25","objectID":"/zh-tw/posts/remove-ds_store-from-all-git-repo.html:0:0","tags":["Git","gitignore","Tool"],"title":"從所有的 git repository 移除 .DS_Store 追蹤","uri":"/zh-tw/posts/remove-ds_store-from-all-git-repo.html"},{"categories":["Git"],"content":"git config 指令 git config 這個指令可以拿來對 git 的各種值做設定， 最出名的就是 git config --global user.name 和 git config --global user.email這種， 對 user.name 和 user.email 做 global 的設定， 之後每個 Repository 就可以沿用設定好的 user.name 和 user.email； 這個指令也可以針對個別的 git repository 做單獨設定， 如果想要針對個別 Repository 設定不同的 user.name 和 user.email， 只要在那個 Repository 下用git config --local user.name 和 git config --local user.email 去單獨做local 的設定就好。 git config 有一個叫 core.excludesfile 的設定， 可以用來指定一個檔案， 裡面可以放希望被 ignore 的檔案， 把這個東西設定到 global， 之後所有的 repository 就都會忽略那個檔案裡面包含的東西。 所以如果要讓所有的 Repository 都忽略 .DS_Store， 就只要把 .DS_Store 和 **/.DS_Store 寫到一個檔案， 再把 core.excludesfile 的值設定成那個檔案就可以了。 可以用下面的指令做到這件事: echo \".DS_Store\" \u003e\u003e ~/.gitignore_global echo \"**/.DS_Store\" \u003e\u003e ~/.gitignore_global git config --global core.excludesfile ~/.gitignore_global","date":"2019-12-25","objectID":"/zh-tw/posts/remove-ds_store-from-all-git-repo.html:1:0","tags":["Git","gitignore","Tool"],"title":"從所有的 git repository 移除 .DS_Store 追蹤","uri":"/zh-tw/posts/remove-ds_store-from-all-git-repo.html"},{"categories":["Concurrency"],"content":"Concurrent Processing 和 Parallel Processing 指的都是 CPU 在 一段時間內執行多個 process， 但兩者在概念上有些差異； 根據 The Art of Concurrency ， Concurrent 指的是 two or more processes are in progress at the same time 而 Parallel 指的是 two or more processes executing simultaneously 看起來很相似但實際上執行的方式不同。 Concurrent 指的是兩個或多個 process 都正在執行中， 而 parallel 指的是兩個或多個 process 同時執行。 舉例來說， 執行兩個 Process， Process A 和 Process B。 ","date":"2019-12-25","objectID":"/zh-tw/posts/concurrent-process-parallel-process.html:0:0","tags":["Programming","Concurrent Processing","Parallel Processing"],"title":"Difference between Concurrent Processing and Parallel Processing","uri":"/zh-tw/posts/concurrent-process-parallel-process.html"},{"categories":["Concurrency"],"content":"Parallel Processing Parallel processing 的執行方式可能長這樣： Process A 和 Process B 同時都在執行。 ","date":"2019-12-25","objectID":"/zh-tw/posts/concurrent-process-parallel-process.html:0:1","tags":["Programming","Concurrent Processing","Parallel Processing"],"title":"Difference between Concurrent Processing and Parallel Processing","uri":"/zh-tw/posts/concurrent-process-parallel-process.html"},{"categories":["Concurrency"],"content":"Concurrent Processing 但對 Concurrent processing 來說， 執行的狀況可以像上面的 Parallel processing， 也可以長這樣： Process A 和 Process B 都在執行中， 但是兩者是交互執行的而非同時執行。 ","date":"2019-12-25","objectID":"/zh-tw/posts/concurrent-process-parallel-process.html:0:2","tags":["Programming","Concurrent Processing","Parallel Processing"],"title":"Difference between Concurrent Processing and Parallel Processing","uri":"/zh-tw/posts/concurrent-process-parallel-process.html"},{"categories":["Concurrency"],"content":"Notice 要特別注意的一點是， parallel processing 只是 concurrent processing 的一種。 只要是有兩個以上的 process 同時在執行中就是 Concurrent processing， 達成這樣的目標有很多種做法， 而 parallel processing 只是其中之一。 ","date":"2019-12-25","objectID":"/zh-tw/posts/concurrent-process-parallel-process.html:0:3","tags":["Programming","Concurrent Processing","Parallel Processing"],"title":"Difference between Concurrent Processing and Parallel Processing","uri":"/zh-tw/posts/concurrent-process-parallel-process.html"}]